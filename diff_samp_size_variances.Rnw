\documentclass{article}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# this is equivalent to \SweaveOpts{...}
opts_chunk$set(fig.path='figures/', fig.align='center', fig.show='hold')
options(replace.assign=TRUE,width=60)
@

<<prelims>>=
## Load libraries
library(splines)
library(MASS)
library(xtable)

## Set the value of lambda
lambda <- 0.8

## Calculate maximum variance bound for different numbers of tests
nTests <- c(10, 100, 1000, 10000)
@

\section{Probability of being a false positive as a linear function of time}

<<linearFuncTime_multSim>>=
set.seed(1345)

##save the variance bound for each m
maxSm <- rep(NA, length(nTests))
 
for(m in 1:length(nTests))
  {
  ntest <- nTests[m]
  
  ## Set up the time vector and the probability of being null
  tme <- seq(-1,2,length=ntest)
  pi0 <- 1/4*tme+1/2
  
  ## Calculate a random variable indicating whether to draw
  ## the p-values from the null or alternative
  nullI <- rbinom(ntest,prob=pi0,size=1)> 0
  
  ## Sample the null P-values from U(0,1) and the alternatives
  ## from a beta distribution
  
  pValues <- rep(NA,ntest)
  pValues[nullI] <- runif(sum(nullI))
  pValues[!nullI] <- rbeta(sum(!nullI),1,50)
  
  ## Get the estimate
  
  y <- pValues > lambda
  glm1 <- glm(y ~ tme, x=TRUE)
  
  ##Get the variance bounds:
  zMat <- glm1$x
  S <- zMat%*%solve(t(zMat)%*%zMat)%*%t(zMat)
  maxSm[m] <- 
    max(diag(S)/(4*(1-lambda)^2))
  } 

xtable(matrix(maxSm, nrow=1), digits=3)
@

\section{Probability of being a false positive as a smooth function of time}

Linear term only:

<<smoothFuncTime_fitLin_multSim>>=
set.seed(1345)

##save the variance bound for each m
maxSm <- rep(NA, length(nTests))

for(m in 1:length(nTests))
  {
  ntest <- nTests[m]
  
  ## Set up the time vector and the probability of being null
  tme <- seq(-1,2,length=ntest)
  pi0 <- pnorm(tme)
  
  ## Calculate a random variable indicating whether to draw
  ## the p-values from the null or alternative
  nullI <- rbinom(ntest,prob=pi0,size=1)> 0
  
  ## Sample the null P-values from U(0,1) and the alternatives
  ## from a beta distribution
  
  pValues <- rep(NA,ntest)
  pValues[nullI] <- runif(sum(nullI))
  pValues[!nullI] <- rbeta(sum(!nullI),1,50)
  
  ## Get the estimate
  
  y <- pValues > lambda
  glm1 <- glm(y ~ tme, x=TRUE)
  
  ##Get the variance bounds:
  zMat <- glm1$x
  S <- zMat%*%solve(t(zMat)%*%zMat)%*%t(zMat)
  maxSm[m] <- 
    max(diag(S)/(4*(1-lambda)^2))
  } 

xtable(matrix(maxSm, nrow=1), digits=3)
@

B-splines with 3 degrees of freedom:

<<smoothFuncTime_multSim>>=
set.seed(1345)

##save the variance bound for each m
maxSm <- rep(NA, length(nTests))

for(m in 1:length(nTests))
  {
  ntest <- nTests[m]
  
  ## Set up the time vector and the probability of being null
  tme <- seq(-1,2,length=ntest)
  pi0 <- pnorm(tme)
  
  ## Calculate a random variable indicating whether to draw
  ## the p-values from the null or alternative
  nullI <- rbinom(ntest,prob=pi0,size=1)> 0
  
  ## Sample the null P-values from U(0,1) and the alternatives
  ## from a beta distribution
  
  pValues <- rep(NA,ntest)
  pValues[nullI] <- runif(sum(nullI))
  pValues[!nullI] <- rbeta(sum(!nullI),1,50)
  
  ## Get the estimate
  
  y <- pValues > lambda
  glm1 <- glm(y ~ ns(tme,df=3), x=TRUE)
  
  ##Get the variance bounds:
  zMat <- glm1$x
  S <- zMat%*%solve(t(zMat)%*%zMat)%*%t(zMat)
  maxSm[m] <- 
    max(diag(S)/(4*(1-lambda)^2))
  } 


xtable(matrix(maxSm, nrow=1), digits=3)
@

\section{Probability of being a false positive as a sine + step function}

3 degrees of freedom on the B-spline:

<<sineStepTime3_multSim>>=
set.seed(1345)

##save the variance bound for each m
maxSm <- rep(NA, length(nTests))
 
for(m in 1:length(nTests))
  {
  ntest <- nTests[m]

  ## Set up the time vector and the probability of being null
  tme1 <- seq(-1*pi,2*pi,length=ntest)
  tme2 <- rep(1:0, each=ntest/2)
  pi0 <- 1/4*sin(tme1) + tme2/4 + 1/2
  
  ## Calculate a random variable indicating whether to draw
  ## the p-values from the null or alternative
  nullI <- rbinom(ntest,prob=pi0,size=1)> 0
  
  ## Sample the null P-values from U(0,1) and the alternatives
  ## from a beta distribution
  
  pValues <- rep(NA,ntest)
  pValues[nullI] <- runif(sum(nullI))
  pValues[!nullI] <- rbeta(sum(!nullI),1,50)
  
  ## Get the estimate
  
  y <- pValues > lambda
  glm1 <- glm(y ~ ns(tme1,df=3) + tme2, x=TRUE)
  
  ##Get the variance bounds:
  zMat <- glm1$x
  S <- zMat%*%ginv(t(zMat)%*%zMat)%*%t(zMat)
  maxSm[m] <- 
    max(diag(S)/(4*(1-lambda)^2))
  } 

xtable(matrix(maxSm, nrow=1), digits=3)
@

20 degrees of freedom on the B-spline:

<<sineStepTime20_multSim>>=
set.seed(1345)

##save the variance bound for each m
maxSm <- rep(NA, length(nTests))

for(m in 1:length(nTests))
  {
  ntest <- nTests[m]
    
  ## Set up the time vector and the probability of being null
  tme1 <- seq(-1*pi,2*pi,length=ntest)
  tme2 <- rep(1:0, each=ntest/2)
  pi0 <- 1/4*sin(tme1) + tme2/4 + 1/2

  ## Calculate a random variable indicating whether to draw
  ## the p-values from the null or alternative
  nullI <- rbinom(ntest,prob=pi0,size=1)> 0
  
  ## Sample the null P-values from U(0,1) and the alternatives
  ## from a beta distribution
  
  pValues <- rep(NA,ntest)
  pValues[nullI] <- runif(sum(nullI))
  pValues[!nullI] <- rbeta(sum(!nullI),1,50)
  
  ## Get the estimate
  
  y <- pValues > lambda
  glm1 <- glm(y ~ ns(tme1,df=20) + tme2, x=TRUE)
  
  ##Get the variance bounds:
  zMat <- glm1$x
  S <- zMat%*%ginv(t(zMat)%*%zMat)%*%t(zMat)
  maxSm[m] <- 
    max(diag(S)/(4*(1-lambda)^2))
  } 

xtable(matrix(maxSm, nrow=1), digits=3)
@

Session info:
<<sessInf>>=
devtools::session_info()
@

\end{document}
