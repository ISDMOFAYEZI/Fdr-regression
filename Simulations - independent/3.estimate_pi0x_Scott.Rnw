\documentclass{article}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# this is equivalent to \SweaveOpts{...}
opts_chunk$set(fig.path='Figures/', fig.align='center', fig.show='hold')
options(replace.assign=TRUE,width=60)
@

<<prelims>>=
## Load libraries
library(splines)
library(MASS)
library(FDRreg)
library(curl)

library(doParallel) ##to make cluster (on Windows)
library(foreach) ##to use foreach function that does the parallel processing
library(doRNG) ##for reproducible seeds when doing parallel processing
@

\section{Probability of being a false positive as a linear function of time}

Load simulations and (re)define some variables:

<<linearFuncTime>>=
load("simResults_1.RData")

nSims <- length(pValuesSims)
ntest <- length(pValuesSims[[1]])

## Set up the time vector and the probability of being null
tme <- seq(-1,2,length=ntest)
pi0 <- 1/4*tme+1/2
@

Perform estimation and save estimates:

<<>>=
cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

set.seed(31084)

pi0hatScottMat <- foreach(sim=1:nSims, .combine="rbind", .packages="FDRreg", .errorhandling="remove") %dorng% {
  ##first transform the p-values into z-scores
  ##randomly assign positive or negative sign
  zScores <- qnorm(1-pValuesSims[[sim]]/2)##*sample(c(-1,1), replace=TRUE, size=length(pValues)); 
  fdr <- FDRreg(zScores, matrix(tme, ncol=1),
                nulltype = 'empirical',
                control=list(lambda=1));
  pi0hatScott.sim <- 1-fdr$priorprob
}

##close the cluster
stopCluster(cl)

dim(pi0hatScottMat)

pi0hatScottMean <- colMeans(pi0hatScottMat)
pi0hatScottVar <- apply(pi0hatScottMat,2,var)

length(pi0hatScottMean)

##save results
save(file="simResults_pi0x_Scott_1.RData", 
     list=c("tme", "pi0", 
            "pi0hatScottMean","pi0hatScottVar"))
@

\section{Probability of being a false positive as a smooth function of time}

Load simulations and (re)define some variables:

<<smoothFuncTime>>=
load("simResults_2.RData")

nSims <- length(pValuesSims)
ntest <- length(pValuesSims[[1]])

## Set up the time vector and the probability of being null
tme <- seq(-1,2,length=ntest)
pi0 <- pnorm(tme)

splineMat <- ns(tme,df=3)
@

Perform estimation and save estimates:

<<>>=
cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

set.seed(31084)

pi0hatScottMatFitLin <- foreach(sim=1:nSims, .combine="rbind", .packages="FDRreg", .errorhandling="remove") %dorng% {
  zScores <- qnorm(1-pValuesSims[[sim]]/2)##*sample(c(-1,1), replace=TRUE, size=length(pValues));
  fdr <- FDRreg(zScores, tme,
                nulltype = 'empirical',
                control=list(lambda=1));
  pi0hatScottMatFitLin.sim  <- 1-fdr$priorprob
}

##close the cluster
stopCluster(cl)

cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

set.seed(31084)

pi0hatScottMatFitSpl <- foreach(sim=1:nSims, .combine="rbind", .packages="FDRreg", .errorhandling="remove") %dorng% {
  zScores <- qnorm(1-pValuesSims[[sim]]/2)##*sample(c(-1,1), replace=TRUE, size=length(pValues));
  fdr <- FDRreg(zScores, splineMat,
                nulltype = 'empirical',
                control=list(lambda=1));
  pi0hatScottMatFitSpl.sim  <- 1-fdr$priorprob
}
  
##close the cluster
stopCluster(cl)

dim(pi0hatScottMatFitLin)
dim(pi0hatScottMatFitSpl)

pi0hatLin.ScottMean <- colMeans(pi0hatScottMatFitLin)
pi0hatLin.ScottVar <- apply(pi0hatScottMatFitLin,2,var)

pi0hatSpl.ScottMean <- colMeans(pi0hatScottMatFitSpl)
pi0hatSpl.ScottVar <- apply(pi0hatScottMatFitSpl,2,var)

length(pi0hatLin.ScottMean)
length(pi0hatSpl.ScottMean)

##save results
save(file="simResults_pi0x_Scott_2.RData", 
     list=c("tme", "pi0", 
            "pi0hatLin.ScottMean", "pi0hatLin.ScottVar",
            "pi0hatSpl.ScottMean", "pi0hatSpl.ScottVar"))
@

\section{Probability of being a false positive as a sine + step function}

Load simulations and (re)define some variables:

<<sineStepTime>>=
load("simResults_3.RData")

nSims <- length(pValuesSims)
ntest <- length(pValuesSims[[1]])

## Set up the time vector and the probability of being null
tme1 <- seq(-1*pi,2*pi,length=ntest)
tme2 <- rep(1:0, each=ntest/2)

pi0 <- 1/4*sin(tme1) + tme2/4 + 1/2
range(pi0)

splineMat3 <- cbind(ns(tme1,df=3), tme2)
splineMat20 <- cbind(ns(tme1,df=20), tme2)
@

Perform estimation and save estimates:

<<>>=
cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

set.seed(31084)

pi0hatScottMat3 <- foreach(sim=1:nSims, .combine="rbind", .packages="FDRreg", .errorhandling="remove") %dorng% {
  zScores <- qnorm(1-pValuesSims[[sim]]/2)##*sample(c(-1,1), replace=TRUE, size=length(pValues)); 
  fdr <- FDRreg(zScores, splineMat3,
                nulltype = 'empirical',
                control=list(lambda=1));
  pi0hatScottMat3.sim  <- 1-fdr$priorprob
}

##close the cluster
stopCluster(cl)

cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

set.seed(31084)

pi0hatScottMat20 <- foreach(sim=1:nSims, .combine="rbind", .packages="FDRreg", .errorhandling="remove") %dorng% {
  zScores <- qnorm(1-pValuesSims[[sim]]/2)##*sample(c(-1,1), replace=TRUE, size=length(pValues)); 
  fdr <- FDRreg(zScores, splineMat20,
                nulltype = 'empirical',
                control=list(lambda=1));
  pi0hatScottMat20.sim  <- 1-fdr$priorprob
}

##close the cluster
stopCluster(cl)

dim(pi0hatScottMat3)
dim(pi0hatScottMat20)

pi0hat3.ScottMean <- colMeans(pi0hatScottMat3)
pi0hat3.ScottVar <- apply(pi0hatScottMat3,2,var)

pi0hat20.ScottMean <- colMeans(pi0hatScottMat20)
pi0hat20.ScottVar <- apply(pi0hatScottMat20,2,var)

length(pi0hat3.ScottMean)
length(pi0hat20.ScottMean)

##save results
save(file="simResults_pi0x_Scott_3.RData", 
     list=c("tme1", "tme2", "pi0", 
            "pi0hat3.ScottMean", "pi0hat3.ScottVar",
            "pi0hat20.ScottMean", "pi0hat20.ScottVar"))
@

Session info:
<<sessInf>>=
devtools::session_info()
@

\end{document}
