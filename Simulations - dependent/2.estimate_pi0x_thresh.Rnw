\documentclass{article}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# this is equivalent to \SweaveOpts{...}
opts_chunk$set(fig.path='Figures/', fig.align='center', fig.show='hold')
options(replace.assign=TRUE,width=60)
@

<<prelims>>=
## Load libraries
library(splines)
library(MASS)
library(swfdr)

library(doParallel) ##to make cluster (on Windows)
library(foreach) ##to use foreach function that does the parallel processing
library(doRNG) ##for reproducible seeds when doing parallel processing
##don't need doRNG here, but easier to keep it in
@

Function to pull out means and variances across simulations:

<<>>=
pullMeansVars <- function(pi0EstSim)
{
  ##pull out estimates at lambda=0.8, lambda=0.9, and final estimate
  pi0hat0.8 <- sapply(pi0EstSim, function(x){x[[1]]})
  pi0hat0.9 <- sapply(pi0EstSim, function(x){x[[2]]})
  pi0hatFinal <- sapply(pi0EstSim, function(x){x[[3]]})
  
  ##get means across simulations
  pi0hatMean0.8 <- rowMeans(pi0hat0.8)
  pi0hatMean0.9 <- rowMeans(pi0hat0.9)
  pi0hatMeanFinal <- rowMeans(pi0hatFinal)
  
  ##also get variances across simulations
  pi0hatVar0.8 <- apply(pi0hat0.8,1,var)
  pi0hatVar0.9 <- apply(pi0hat0.9,1,var)
  pi0hatVarFinal <- apply(pi0hatFinal,1,var)

  return(list(pi0hatMean0.8=pi0hatMean0.8, 
              pi0hatMean0.9=pi0hatMean0.9, 
              pi0hatMeanFinal=pi0hatMeanFinal,
              pi0hatVar0.8=pi0hatVar0.8, 
              pi0hatVar0.9=pi0hatVar0.9, 
              pi0hatVarFinal=pi0hatVarFinal))  
}
@

\section{Probability of being a false positive as a linear function of time}

Load simulations and (re)define some variables:

<<linearFuncTime>>=
load("simResults_1.RData")

nSims <- length(pValuesSims)
ntest <- length(pValuesSims[[1]])

##sequence of lambdas
lambdas <- round(seq(0.05, 0.95, 0.05),2)
which.0.8 <- which(lambdas==0.8)
which.0.9 <- which(lambdas==0.9)
which.0.8
which.0.9

## Set up the time vector and the probability of being null
tme <- seq(-1,2,length=ntest)
pi0 <- 1/4*tme+1/2
@

Perform estimation and save estimates:

<<>>=
cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

pi0EstSim <- foreach(sim = 1:nSims, .packages=c("swfdr")) %dorng% {  
  res <- lm_pi0(pValuesSims[[sim]], lambda=lambdas, X=tme, 
                smooth.df=3, threshold=TRUE);
  res.pi0.lambda <- res$pi0.lambda;
  list(res.pi0.lambda[,which.0.8], 
       res.pi0.lambda[,which.0.9],
       res$pi0)}

##close the cluster
stopCluster(cl)

##pull out means and variances of estimates at lambda=0.8, lambda=0.9, and final estimate
pi0MeansVars <- pullMeansVars(pi0EstSim)

##save results
save(file="simResults_pi0x_thresh_1.RData", 
     list=c("tme", "pi0", "pi0MeansVars"))
@

\section{Probability of being a false positive as a smooth function of time}

Load simulations and (re)define some variables:

<<smoothFuncTime>>=
load("simResults_2.RData")

nSims <- length(pValuesSims)
ntest <- length(pValuesSims[[1]])

##sequence of lambdas
lambdas <- round(seq(0.05, 0.95, 0.05),2)
which.0.8 <- which(lambdas==0.8)
which.0.9 <- which(lambdas==0.9)
which.0.8
which.0.9

## Set up the time vector and the probability of being null
tme <- seq(-1,2,length=ntest)
pi0 <- pnorm(tme)

splineMat <- ns(tme,df=3)
@

Perform estimation and save estimates:

<<>>=
cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

pi0EstSim.lin <- foreach(sim = 1:nSims, .packages=c("swfdr")) %dorng% {  
  res <- lm_pi0(pValuesSims[[sim]], lambda=lambdas, X=tme, 
                smooth.df=3, threshold=TRUE);
  res.pi0.lambda <- res$pi0.lambda;
  list(res.pi0.lambda[,which.0.8], 
       res.pi0.lambda[,which.0.9],
       res$pi0)}

##close the cluster
stopCluster(cl)

cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

pi0EstSim.spl <- foreach(sim = 1:nSims, .packages=c("swfdr")) %dorng% {  
  res <- lm_pi0(pValuesSims[[sim]], lambda=lambdas, X=splineMat, 
                smooth.df=3, threshold=TRUE);
  res.pi0.lambda <- res$pi0.lambda;
  list(res.pi0.lambda[,which.0.8], 
       res.pi0.lambda[,which.0.9],
       res$pi0)}

##close the cluster
stopCluster(cl)

##pull out means and variances of estimates at lambda=0.8, lambda=0.9, and final estimate
pi0Lin.MeansVars <- pullMeansVars(pi0EstSim.lin)
pi0Spl.MeansVars <- pullMeansVars(pi0EstSim.spl)

##save results
save(file="simResults_pi0x_thresh_2.RData", 
     list=c("tme", "pi0", "pi0Lin.MeansVars", "pi0Spl.MeansVars"))
@

\section{Probability of being a false positive as a sine + step function}

Load simulations and (re)define some variables:

<<sineStepTime>>=
load("simResults_3.RData")

nSims <- length(pValuesSims)
ntest <- length(pValuesSims[[1]])

##sequence of lambdas
lambdas <- round(seq(0.05, 0.95, 0.05),2)
which.0.8 <- which(lambdas==0.8)
which.0.9 <- which(lambdas==0.9)
which.0.8
which.0.9

## Set up the time vector and the probability of being null
tme1 <- seq(-1*pi,2*pi,length=ntest)
tme2 <- rep(1:0, each=ntest/2)

pi0 <- 1/4*sin(tme1) + tme2/4 + 1/2
range(pi0)

splineMat3 <- cbind(ns(tme1,df=3), tme2)
splineMat20 <- cbind(ns(tme1,df=20), tme2)
@

Perform estimation and save estimates:

<<>>=
cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

pi0EstSim3 <- foreach(sim = 1:nSims, .packages=c("swfdr")) %dorng% {  
  res <- lm_pi0(pValuesSims[[sim]], lambda=lambdas, X=splineMat3, 
                smooth.df=3, threshold=TRUE);
  res.pi0.lambda <- res$pi0.lambda;
  list(res.pi0.lambda[,which.0.8], 
       res.pi0.lambda[,which.0.9],
       res$pi0)}

##close the cluster
stopCluster(cl)

cl<-makeCluster(8) ##specify number of cores less than or equal to number of cores on your computer
registerDoParallel(cl)

pi0EstSim20 <- foreach(sim = 1:nSims, .packages=c("swfdr")) %dorng% {  
  res <- lm_pi0(pValuesSims[[sim]], lambda=lambdas, X=splineMat20, 
                smooth.df=3, threshold=TRUE);
  res.pi0.lambda <- res$pi0.lambda;
  list(res.pi0.lambda[,which.0.8], 
       res.pi0.lambda[,which.0.9],
       res$pi0)}

##close the cluster
stopCluster(cl)

##pull out means and variances of estimates at lambda=0.8, lambda=0.9, and final estimate
pi0_3.MeansVars <- pullMeansVars(pi0EstSim3)
pi0_20.MeansVars <- pullMeansVars(pi0EstSim20)

##save results
save(file="simResults_pi0x_thresh_3.RData", 
     list=c("tme1", "tme2", "pi0", 
            "pi0_3.MeansVars", "pi0_20.MeansVars"))
@

Session info:
<<sessInf>>=
devtools::session_info()
@

\end{document}
